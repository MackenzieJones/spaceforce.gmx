<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_dialoguebox</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(instance_number(obj_textevent)&gt;1 or instance_number(obj_textbox)&gt;1){ instance_destroy(); exit; }
 
//-----------Customise (FOR USER)
interact_key        = ord("E");
up_key              = vk_up;        //for dialogue choices
down_key            = vk_down;      //for dialogue choices
 
scale               = 3;
x_buffer            = 10 * scale;
y_buffer            = 8 * scale;
 
portrait_frame      = spr_portraitframe;
dialogue_box        = spr_dialoguebox;
name_box            = spr_namebox;
finished_effect     = spr_dialoguefinished;
emote_sprite        = spr_emotes;
 
choice_snd_effect   = snd_moveselect;
select_snd_effect   = snd_select;
 
default_col         = c_white;
choice_col          = c_yellow;
select_col          = c_orange;

name_col            = c_purple;
name_font           = fnt_dialogue;

finishede_spd       = 12/room_speed; //frames per second

priority_snd_effect = 5;
open_mouth_frame    = 1;    //You only need to change this if you are using animated sprites
                            //Set this to equal the frame where the mouth is OPEN for talking sprites
 
//-----------Setup (LEAVE THIS STUFF)

portrait_talk   = -1;
portrait_talk_n = -1;
portrait_talk_s = -1;
portrait_talk_c = 0;
 
portrait_idle   = -1;
portrait_idle_n = -1;
portrait_idle_s = -1;
portrait_idle_c = 0;
 
emotes          = -1;
speaker         = noone;
 
boxHeight       = sprite_get_height(dialogue_box) * scale;
boxWidth        = sprite_get_width(dialogue_box) * scale;
gui_width       = display_get_gui_width();
gui_height      = display_get_gui_height();
gb_diff         = gui_width - boxWidth;
portraitWidth   = sprite_get_width(portrait_frame) * scale;
finishede_num   = sprite_get_number(finished_effect);
 
pos_x           = (gb_diff/2)+(portraitWidth/2);
pos_y           = gui_height-boxHeight-8;
 
name_box_x          = pos_x + (8 * scale);
name_box_y          = pos_y - (23 * scale);
name_box_text_x     = name_box_x + ((sprite_get_width(name_box)*scale)/2);
name_box_text_y     = name_box_y + y_buffer;

finishede_x     = pos_x + boxWidth - x_buffer;
finishede_y     = pos_y + boxHeight - y_buffer;
 
letter          = 0;
charCount       = 0;
charCount_f     = 0;
text_speed      = 0;
text_speed_c    = 0;
audio_c         = 0;
page            = 0;
str_len         = -1;
pause           = false;
chosen          = false;
choice          = 0;
 
creator         = noone;
type            = 0;
text            = -1;
text_NE         = -1;
breakpoints     = -1;
nextline        = 0;
text_col        = c_white;
emotion         = 0;
 
portrait        = 1;
voice           = 1;
font            = 1;
 
charSize        = 1;
stringHeight    = 1;
 
//---------------------Effect variables
 
t           = 0;
amplitude   = 3;
freq        = 2;
ec          = 0;    //effect c
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This is made to be an alarm so we can have a small "pause" after selecting a dialogue option
 
//---------Update choice and page
 
//Change an object's variable according to choice if applicable
var cv = executeScript[page];
if(is_array(cv)){
	cv = cv[choice];
	var len = array_length_1d(cv)-1;
	var cva = array_create(len);
	array_copy(cva, 0, cv, 1, len); 
	script_execute_alt(cv[0], cva);
}

 
//Update page
if(page+1 &lt; array_length_1d(text)){
    var nl = nextline[page];
    switch(nl[choice]){
        case -1: instance_destroy();    exit;
        case  0: page += 1;             break;
        default: page = nl[choice];
    }
    event_perform(ev_alarm, 0);
   
} else {
    instance_destroy();
}
 
chosen = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pause
//Unpauses when this alarm goes off
pause = false;
charCount += 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Must be done AFTER the handover occurs, so frame after created, and after every text page change
 
//--------Reset variables
charCount       = 0;
finishede_count = 0;
portrait_talk_c = 0;
portrait_idle_c = 0;
text_speed_c    = 0;
audio_c         = 0;
charCount_f     = 0;
effects_p       = effects[page];
text_col_p      = text_col[page];
 
text_speed_al   = array_length_1d(text_speed[page])/2;
effects_al      = array_length_1d(effects[page])/2;
text_col_al     = array_length_1d(text_col[page])/2;
 
if(portrait[page] == -1){
    pos_x           = (gb_diff/2);
    finishede_x     = pos_x + boxWidth - x_buffer;
} else {
    pos_x           = (gb_diff/2)+(portraitWidth/2);
    finishede_x     = pos_x + boxWidth - x_buffer;
}
 
draw_set_font(font[page]);
charSize = string_width("M");       //gets new charSize under current font
charHeight = string_height("M");    //same for width
//--------
 
//--------GET THE BREAKPOINTS AND TEXT EFFECTS
//Again only need to do this if our CURRENT page is "normal". Separated from above for readability.
if(type[page] == 0){
    text_NE = text[page];
    str_len = string_length(text_NE);
   
    //Get variables ready
    var by = 0, ty = 0, cc = 1, breakpoint = 0;
    var next_space = 0, char, txtwidth = boxWidth-(2*x_buffer), char_max = txtwidth div charSize;
 
    //Reset the text effects and breakpoints arrays
    text_effects = -1;
    breakpoints = -1;
   
    //Loop through and save the effect positions and breakpoints
    repeat(str_len){
        //Save Effect Positions
        char = string_char_at(text[page], cc);
       
        //Get next space, deal with new lines
        if(cc &gt;= next_space){
            next_space = cc;
            while(next_space &lt; str_len and string_copy(text_NE, next_space,1) != " ") next_space++;
            var linewidth = (next_space-breakpoint)*charSize;
            if (linewidth &gt;= txtwidth) { breakpoint = cc; breakpoints[by] = cc; by++; }
        }
   
        cc++;
    }
}

           
//--------Get the emotes
if(emotes != -1 and emotes[page] != -1){
    var sp = speaker[page]; var ep = emotes[page];
    var obj = instance_create(sp.x,sp.y-sp.sprite_height-2,obj_emote);
    var spr = emote_sprite;
    with(obj){
        sprite_index = spr;
        image_index = ep;
        creator = sp;
        mode = 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//We check the type of dialogue to see if it is 1) "normal" or 2) a player choice dialogue.
 
//----------TYPE 0: NORMAL
if(true){
    if(keyboard_check_pressed(interact_key)){
 
        //If we haven't "typed out" all the letters, immediately "type out" all letters (works as a "skip")
        if(charCount &lt; str_len){
            charCount = string_length(text_NE);
        }
       
        //Only increase page IF page + 1,is less than the total number of entries
        else if(page+1 &lt; array_length_1d(text)){
            event_perform(ev_other, ev_user0);
            switch(nextline[page]){
                case -1: instance_destroy();    exit;
                case  0: page += 1;             break;
                default: page = nextline[page];
            }
            event_perform(ev_alarm, 0);
           
        } else { event_perform(ev_other, ev_user0); instance_destroy(); }
    }
}
 
//----------TYPE 1: DIALOGUE CHOICE
else {
    if(chosen) exit;
    if(keyboard_check_pressed(interact_key)){
        chosen = true;
        alarm[2] = 10;
        audio_play_sound(select_snd_effect, priority_snd_effect, false);
    }
   
    //Change Choice
    var change_choice = keyboard_check_pressed(down_key) - keyboard_check_pressed(up_key);
    if(change_choice != 0){
        choice += change_choice;
        audio_play_sound(choice_snd_effect, priority_snd_effect, false);
    }
    if (choice &lt; 0) { choice = array_length_1d(text[page])-1; }
    else if (choice &gt; array_length_1d(text[page])-1) { choice = 0; }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var cv = executeScript[page];
    if(is_array(cv)){
    var len = array_length_1d(cv)-1;
    var cva = array_create(len);
    array_copy(cva, 0, cv, 1, len);
    var c = cva;
    script_execute_alt(cv[0], cva);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw textbox
draw_sprite_ext(dialogue_box, 0, pos_x,pos_y, scale,scale, 0, c_white, 1);
 
//Draw portrait
if(false){
    draw_sprite_ext(portrait[page], emotion[page], pos_x-portraitWidth, pos_y, scale,scale, 0, c_white, 1);
 
    //---------Idle Animated Portrait
if(type[page] == 1 or charCount &gt;= str_len) {
    if(portrait_idle[page] != -1){
        var posx = pos_x-portraitWidth; var posy = pos_y;
        if(portrait_idle_x[page] != -1){ posx += portrait_idle_x[page] * scale; }
        if(portrait_idle_y[page] != -1){ posy += portrait_idle_y[page] * scale; }
       
        portrait_idle_c += portrait_idle_s[page];
        if(portrait_idle_c &gt;= portrait_idle_n[page]){ portrait_idle_c = 0; }
        draw_sprite_ext(portrait_idle[page], portrait_idle_c, posx, posy, scale,scale, 0, c_white, 1); 
    }
}
 
    draw_sprite_ext(portrait_frame, 0, pos_x-portraitWidth, pos_y, scale,scale, 0, c_white, 1);
}

//Draw name and namebox
var cname = name[page]

if(cname != "None"){
    //Draw namebox
    draw_sprite_ext(name_box, 0, name_box_x,name_box_y, scale,scale, 0, c_white, 1);

    //Draw name text
    var c = name_col;
    draw_set_halign(fa_center);
    draw_set_font(name_font);
    draw_text_color(name_box_text_x, name_box_text_y, cname, c,c,c,c, 1);
    draw_set_halign(fa_left);
}

//Set font
draw_set_font(font[page]);
 
//--------Draw the text differently if we are in 1) a dialogue choice or 2) normal dialogue
//---------TYPE 1: DIALOGUE CHOICE
if(type[page] == 1){
    //Variables we need
    var col = default_col, tp = text[page], tpl = array_length_1d(tp), txtwidth = boxWidth-(2*x_buffer);
    var cc = 1, yy = pos_y+y_buffer, xx = pos_x+x_buffer, ii = 0, iy = 0;
   
    //Loop through our choices, draw them, highlight the one we are selecting
    repeat(tpl){
        if(choice == ii){
            if(chosen) { col = select_col; }
            else       { col = choice_col; }
        } else { col = c_white; }
       
        //Draw our choices
        var ctext = "* "+tp[ii];
        draw_text_ext_color(xx, yy+((ii+iy)*stringHeight), ctext, stringHeight, txtwidth, col, col, col, col, 1);
       
        if(string_width(ctext) &gt; txtwidth) { iy++; }
        ii++;
    }
}
 
//---------TYPE 0: NORMAL DIALOGUE
else {
    //Detect pauses, play voice sound, increment our "typewriter"
    //Only need to do this if we haven't typed everything out AND we aren't already paused
   
    if(charCount &lt; str_len and !pause){
       
       //---------Increment character counter (charCount) every frame, used for "typewriter"
        var tsc2 = text_speed_c*2;
        var txtspd = text_speed[page];
        if(text_speed_c+1 &lt; text_speed_al and charCount == txtspd[tsc2+2]) {
            text_speed_c++;
            tsc2 = text_speed_c*2;
        }
        charCount += txtspd[tsc2+1];
       
        //Get Current Character
        var ch = string_char_at(text_NE, floor(charCount));
       
        //---------Check for Pause, Voice, Animated Sprite
        switch(ch){
            case " ": break;
            case ",":
            case ".":
                pause = true;
                alarm[1] = 10;  //how many frames we wait if we detect a fullstop or comma
                break;
           
            case "?":
            case "!":
                pause = true;
                alarm[1] = 20;  //how many frames we wait if we detect a ! or ?
                break;
            default:
               
                //Play the voice sound every 2 frames (you can change this number if this is too often)
                var audio_increment = 2;
               
                //---------Animated Sprite
                if(portrait_talk[page] != -1) {
                    if(!pause) {
                        var posx = pos_x-portraitWidth; var posy = pos_y;
                        if(portrait_talk_x[page] != -1){ posx += portrait_talk_x[page] * scale; }
                        if(portrait_talk_y[page] != -1){ posy += portrait_talk_y[page] * scale; }
       
                        portrait_talk_c += portrait_talk_s[page];
       
                        //To include the consideration of vowels
                        //*/
                        var l = string_lower(ch);
                        if(l == "a" or l == "e" or l == "i" or l == "o" or l == "u"){
                            portrait_talk_c = open_mouth_frame;
                            if (charCount &gt; audio_c) {
                                audio_play_sound(voice[page], 1, false);
                                audio_c = charCount + audio_increment;
                            }
                        }
                        /*/
                        if (charCount &gt; audio_c) {
                            audio_play_sound(voice[page], 1, false);
                            audio_c = charCount + audio_increment;
                        }
                        //*/
                        if(portrait_talk_c &gt; portrait_talk_n[page]){ portrait_talk_c = 0; }
                        draw_sprite_ext(portrait_talk[page], portrait_talk_c, posx, posy, scale,scale, 0, c_white, 1); 
                    }
                }
                else if (charCount &gt;= audio_c) { audio_play_sound(voice[page], 1, false); audio_c = charCount + audio_increment; }
        }
       
    }
 
    //---------------------------------Setup for Effects----------------------------//
    var col = default_col, cc = 1, yy = pos_y+y_buffer, xx = pos_x+x_buffer, cx = 0, cy = 0, lineswidth;
    var ty = 0, by = 0, bp_len = -1, effect = 0, next_space, breakpoint = 0, effects_c = 0, text_col_c = 0;
    var bp_array = breakpoints, txtwidth = boxWidth-(2*x_buffer), char_max = txtwidth div charSize;
   
    //Check if there are breakpoints in this string, if there are save their lengths
    if(bp_array != -1){ bp_len = array_length_1d(bp_array); next_space = breakpoints[by]; by++; }
   
    //For sin wave stuff
    t += 1;
    var so = t;
    var shift = sin(t*pi*2/60)*3;
   
    //---------------------------------Draw the Letters-----------------------------//
   
    repeat(charCount){
        //Get current letter
        letter = string_char_at(text_NE, cc);
   
        var ec2 = effects_c*2;
        if(effects_c &lt; effects_al and effects_p[ec2] == cc){
            effects_c++;
            effect = effects_p[ec2+1];
        }
       
        var tc2 = text_col_c*2;
        if(text_col_c &lt; text_col_al and text_col_p[tc2] == cc){
            text_col_c++;
            col = text_col_p[tc2+1];
        }
       
        //Get next space, deal with new lines
        if(bp_len != -1 and cc == next_space){
            cy += 1; cx = 0;
            if(by &lt; bp_len){
                next_space = breakpoints[by];
                by++;
            }
        }
       
        switch(effect){
            case 0: //normal
                draw_text_color(xx + (cx*charSize), yy+(cy*stringHeight), letter, col, col, col, col, 1);
                break;
           
            case 1: //shakey
                draw_text_color(xx + (cx*charSize)+random_range(-1,1), yy+(cy*stringHeight)+random_range(-1,1), letter, col, col, col, col, 1);
                break;
           
            case 2: //wave
                var so = t;
                var shift = sin(so*pi*freq/room_speed)*amplitude;
                draw_text_color(xx + (cx*charSize), yy+(cy*stringHeight)+shift, letter, col, col, col, col, 1);
                break;
           
            case 3: //colour shift
                var c1 = make_colour_hsv(t+cc, 255, 255);
                var c2 = make_colour_hsv(t+cc+34, 255, 255);
                draw_text_color(xx + (cx*charSize), yy+(cy*stringHeight), letter, c1, c1, c2, c2, 1);
                break;
       
            case 4: //wave AND colour shift
                var so = t + cc;
                var shift = sin(so*pi*freq/room_speed)*amplitude;
                var c1 = make_colour_hsv(t+cc, 255, 255);
                var c2 = make_colour_hsv(t+cc+45, 255, 255);
                draw_text_color(xx + (cx*charSize), yy+(cy*stringHeight)+shift, letter, c1, c1, c2, c2, 1);
                break;
       
            case 5: //spin
                var so = t + cc;
                var shift = sin(so*pi*freq/room_speed);
                var mv = charSize/2;
                draw_set_valign(fa_middle); draw_set_halign(fa_middle);
                draw_text_transformed_color(xx + (cx*charSize)+mv, yy+(cy*stringHeight)+(stringHeight/2), letter, 1, 1, shift*20, col, col, col, col, 1);
                draw_set_valign(fa_top); draw_set_halign(fa_left);
                break;
               
            case 6: //pulse
                var so = t + cc;
                var shift = abs(sin(so*pi*freq/room_speed));
                var mv = charSize/2;
                draw_set_valign(fa_middle); draw_set_halign(fa_middle);
                draw_text_transformed_color(xx + (cx*charSize)+mv, yy+(cy*stringHeight)+(stringHeight/2), letter, shift, shift, 0, col, col, col, col, 1);
                draw_set_valign(fa_top); draw_set_halign(fa_left);
                break;
               
            case 7: //flicker
                var so = t + cc;
                var shift = sin(so*pi*freq/room_speed);
                draw_text_color(xx + (cx*charSize), yy+(cy*stringHeight), letter, col, col, col, col, shift+random_range(-1,1));
                break;
        }
       
        //Increment variables for next letter
        cc += 1;
        cx += 1;
    }
   
    //---------Draw "Finished" effect
    if(charCount &gt;= str_len){
        var shift = sin((t+cc)*pi*freq/room_speed)*amplitude;
        finishede_count += finishede_spd;
        if(finishede_count &gt;= finishede_num){ finishede_count = 0; }
        draw_sprite(finished_effect, finishede_count, finishede_x + shift, finishede_y);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
